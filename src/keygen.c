/**
 * @file keygen.c
 * @brief Implementation of key generation functions for the signature scheme
 * 
 * This file implements the key generation process for the post-quantum signature scheme,
 * including functions for generating random seeds, creating generator matrices,
 * generating parity check matrices, and producing public/private key pairs.
 */

#include <string.h>
#include <sodium.h>
#include "keygen.h"
#include "matrix.h"     
#include "utils.h"
#include "params.h"
#include "constants.h"

/**
 * @brief This function generates a random seed of a fixed size.
 * 
 * The function uses the randombytes_buf function from the Sodium library to fill the provided seed buffer with random bytes. The size of the seed is defined by the constant SEED_SIZE, which is set to 32 bytes.
 * 
 * @param seed It is a pointer to an unsigned char array where the generated random seed will be stored. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file.
 * 
 * @return void This function does not return any value. It directly modifies the provided seed buffer by filling it with random bytes.
 */
void generate_random_seed(unsigned char *seed) {
    randombytes_buf(seed, SEED_SIZE);
}

/**
 * @brief Create a generator matrix object.
 * 
 * This function initializes a generator matrix of size k x n with random entries modulo MOD. It uses the FLINT library's nmod_mat_t type to represent the matrix and fills it with random values using the nmod_mat_randtest function. The matrix is initialized with dimensions k (number of rows) and n (number of columns), and the entries are generated randomly in the range of 0 to MOD-1. The process involves the following steps:
 * 1. Random State Initialization: 
 *    A FLINT random state (flint_rand_t) is initialized using flint_randinit. This state is required for generating random numbers in FLINT.
 * 2. Matrix Initialization: 
 *    The generator matrix (gen_matrix) is initialized with k rows and n columns, and modulus MOD, using nmod_mat_init.
 * 3. Random Entry Generation: 
 *    The matrix is filled with random values using nmod_mat_randtest, which uses the previously initialized random state to populate each entry.
 * 4. Random State Cleanup: 
 *    The random state is cleared with flint_randclear to free any resources associated with it.
 * 
 * @note The function does not return any value; it directly modifies the provided gen_matrix object. It also initializes a random state using flint_rand_t to ensure that the random values are generated correctly.
 * 
 * @param n It is the total number of columns in the generator matrix. It represents the length of the codewords generated by the matrix.
 * @param k It is the number of rows in the generator matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded.
 * @param d It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated.
 * @param gen_matrix It is a pointer to an nmod_mat_t type, which represents the generator matrix to be created. The function initializes this matrix with random entries modulo MOD.
 * @param output_file It is a pointer to a FILE object where any output or debug information can be written. This parameter is optional and can be used for logging purposes, but in this implementation, it is not used.
 * 
 * @return void This function does not return any value. It modifies the provided gen_matrix object directly and fills it with random values.
 */
void create_generator_matrix(slong n, slong k, slong d, nmod_mat_t gen_matrix, FILE *output_file) { 
    flint_rand_t state;
    flint_randinit(state);

    nmod_mat_init(gen_matrix, k, n, MOD);
    nmod_mat_randtest(gen_matrix, state);

    flint_randclear(state);
}

/**
 * @brief This function generates a parity check matrix random entries modulo MOD.
 * 
 * The function initializes a parity check matrix of size (n-k) x n with random entries modulo MOD. It uses the FLINT library's nmod_mat_t type to represent the matrix and fills it with random values using the nmod_mat_randtest function. The matrix is initialized with dimensions (n-k) (number of rows) and n (number of columns), and the entries are generated randomly in the range of 0 to MOD-1. The process involves the following steps:
 * 1. Random State Initialization: A FLINT random state (flint_rand_t) is initialized using flint_randinit. This state is required for generating random numbers in FLINT.
 * 2. Matrix Initialization: The parity check matrix (H) is initialized with n-k rows and n columns, and modulus MOD, using nmod_mat_init.
 * 3. Random Entry Generation: The matrix is filled with random values using nmod_mat_randtest, which uses the previously initialized random state to populate each entry.
 * 4. Random State Cleanup: The random state is cleared with flint_randclear to free any resources associated with it.
 * 
 * @note The function does not return any value; it directly modifies the provided H object. It also initializes a random state using flint_rand_t to ensure that the random values are generated correctly.
 * 
 * @param n It is the total number of columns in the parity check matrix. It represents the length of the codewords that the matrix checks for validity.
 * @param k It is the number of rows in the parity check matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded.
 * @param d It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated.
 * @param H It is the pointer to an nmod_mat_t type, which represents the parity check matrix to be created. The function initializes this matrix with random entries modulo MOD.
 * @param output_file It is a pointer to a FILE object where any output or debug information can be written. This parameter is optional and can be used for logging purposes, but in this implementation, it is not used.
 * 
 * @return void This function does not return any value. It modifies the provided H object directly and fills it with random values.
 */
void generate_parity_check_matrix(slong n, slong k, slong d, nmod_mat_t H, FILE *output_file) {
    flint_rand_t state;
    flint_randinit(state);
    
    nmod_mat_randtest(H, state);
    flint_randclear(state);
}

/**
 * @brief Create a generator matrix from seed object.
 * 
 * This function generates a generator matrix of size k x n using a deterministic approach based on a provided seed. The seed is used to generate random entries in the matrix, ensuring that the same seed will always produce the same matrix. The entries are generated modulo MOD. The process involves the following steps:
 * 1. Stream Buffer Allocation: A buffer (stream) is allocated to hold the random bytes needed for the matrix entries. The size of this buffer is determined by the number of entries in the matrix (k * n) multiplied by the size of each entry (4 bytes for a uint32_t).
 * 2. Deterministic Random Generation: The randombytes_buf_deterministic function from the Sodium library is used to fill the buffer with random bytes based on the provided seed. This ensures that the same seed will always produce the same sequence of random bytes. It's important to note that this function uses the ChaCha20 algorithm under the hood for secure random number generation.
 * 3. Matrix Entry Population: The function iterates over each entry in the generator matrix and fills it with values derived from the buffer. Each entry is constructed by combining 4 bytes from the buffer into a single uint32_t value, which is then reduced modulo MOD to fit within the required range.
 * 4. Memory Cleanup: The allocated buffer is freed to avoid memory leaks.
 * 
 * @note The function does not return any value; it directly modifies the provided gen_matrix object. It also requires a seed to ensure deterministic behavior, which is passed as an argument.
 * 
 * @param n It is the total number of columns in the generator matrix. It represents the length of the codewords generated by the matrix.
 * @param k It is the number of rows in the generator matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded.
 * @param d It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated.
 * @param gen_matrix It is a pointer to an nmod_mat_t type, which represents the generator matrix to be created. The function initializes this matrix with random entries modulo MOD.
 * @param seed It is a pointer to an unsigned char array that serves as the seed for the deterministic random number generation. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file.
 * @param output_file It is a pointer to a FILE object where any output or debug information can be written.
 * 
 * @return void This function does not return any value. It modifies the provided gen_matrix object directly and fills it with values derived from the seed.
 */
void create_generator_matrix_from_seed(slong n, slong k, slong d,
                                       nmod_mat_t gen_matrix,
                                       const unsigned char *seed,
                                       FILE *output_file) {

    size_t num_entries = k * n;
    size_t total_bytes = num_entries * sizeof(uint32_t);
    unsigned char *stream = malloc(total_bytes);
    if (!stream) {
        fprintf(stderr, "Failed to allocate stream buffer\n");
        return;
    }

    // this uses ChaCha20 under the hood
    randombytes_buf_deterministic(stream, total_bytes, seed);

    for (slong i = 0; i < k; ++i) {
        for (slong j = 0; j < n; ++j) {
            size_t idx = (i * n + j) * sizeof(uint32_t);
            uint32_t value = 0;
            for (int b = 0; b < 4; ++b) {
                value |= ((uint32_t)stream[idx + b]) << (8 * b);
            }
            nmod_mat_set_entry(gen_matrix, i, j, value % MOD);
        }
    }

    free(stream);
}

/**
 * @brief This function generates a parity check matrix from a seed.
 * 
 * The function initializes a parity check matrix of size (n-k) x n using a deterministic approach based on a provided seed. The seed is used to generate random entries in the matrix, ensuring that the same seed will always produce the same matrix. The entries are generated modulo MOD. The process involves the following steps:
 * 1. Stream Buffer Allocation: A buffer (stream) is allocated to hold the random bytes needed for the matrix entries. The size of this buffer is determined by the number of entries in the matrix ((n-k) * n) multiplied by the size of each entry (4 bytes for a uint32_t).
 * 2. Deterministic Random Generation: The randombytes_buf_deterministic function from the Sodium library is used to fill the buffer with random bytes based on the provided seed. This ensures that the same seed will always produce the same sequence of random bytes. It's important to note that this function uses the ChaCha20 algorithm under the hood for secure random number generation.
 * 3. Matrix Entry Population: The function iterates over each entry in the parity check matrix and fills it with values derived from the buffer. Each entry is constructed by combining 4 bytes from the buffer into a single uint32_t value, which is then reduced modulo MOD to fit within the required range.
 * 4. Memory Cleanup: The allocated buffer is freed to avoid memory leaks.
 * 
 * @note The function does not return any value; it directly modifies the provided H object. It also requires a seed to ensure deterministic behavior, which is passed as an argument.
 * 
 * @param n It is the total number of columns in the parity check matrix. It represents the length of the codewords that the matrix checks for validity.
 * @param k It is the number of rows in the parity check matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded.
 * @param d It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated.
 * @param H It is a pointer to an nmod_mat_t type, which represents the parity check matrix to be created. The function initializes this matrix with random entries modulo MOD.
 * @param seed It is a pointer to an unsigned char array that serves as the seed for the deterministic random number generation. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file.
 * @param output_file It is a pointer to a FILE object where any output or debug information can be written.
 * 
 * @return void This function does not return any value. It modifies the provided H object directly and fills it with values derived from the seed.
 */
void generate_parity_check_matrix_from_seed(slong n, slong k, slong d, nmod_mat_t H, 
                                           const unsigned char *seed, FILE *output_file) {

    size_t num_entries = (n - k) * n;
    size_t total_bytes = num_entries * sizeof(uint32_t);
    unsigned char *stream = malloc(total_bytes);
    if (!stream) {
        fprintf(stderr, "Failed to allocate stream buffer\n");
        return;
    }

    randombytes_buf_deterministic(stream, total_bytes, seed);

    for (slong i = 0; i < n - k; ++i) {
        for (slong j = 0; j < n; ++j) {
            size_t idx = (i * n + j) * sizeof(uint32_t);
            uint32_t value = 0;
            for (int b = 0; b < 4; ++b) {
                value |= ((uint32_t)stream[idx + b]) << (8 * b);
            }
            nmod_mat_set_entry(H, i, j, value % MOD);
        }
    }

    free(stream);
}

/**
 * @brief Get the or generate matrix with seed object.
 * 
 * This function checks if a matrix file exists for the given parameters (prefix, n, k, d). If it does and regeneration is not requested, it loads the matrix from the file. If the file does not exist or regeneration is requested, it generates a new matrix either using a random generation function or a seed-based generation function. The generated matrix is then saved to a file. This function is designed to handle both random and seed-based generation of matrices, allowing for reproducibility when using the same seed.
 * 
 * @param prefix It is a string that serves as a prefix for the filename of the matrix. This prefix is used to create a unique filename based on the parameters n, k, and d.
 * @param n It is the total number of columns in the matrix. It represents the length of the codewords generated by the matrix.
 * @param k It is the number of rows in the matrix. It represents the dimension of the code, which is the number of information symbols that can be encoded.
 * @param d It is the minimum distance of the code. This parameter is not directly used in the function but is typically relevant for the properties of the code being generated.
 * @param matrix It is a pointer to an nmod_mat_t type, which represents the matrix to be generated or loaded. The function initializes this matrix with random entries or loads it from a file if it already exists.
 * @param generate_func It is a pointer to a function that generates a matrix with random entries. This function should take parameters (n, k, d, matrix, output_file) and fill the matrix with random values.
 * @param generate_from_seed_func It is a pointer to a function that generates a matrix from a seed. This function should take parameters (n, k, d, matrix, seed, output_file) and fill the matrix with values derived from the seed.
 * @param output_file It is a pointer to a FILE object where any output or debug information can be written. This parameter is optional and can be used for logging purposes, but in this implementation, it is not used.
 * @param regenerate It is a boolean flag that indicates whether to regenerate the matrix even if it already exists. If set to true, the function will always generate a new matrix; if false, it will load the existing matrix if available.
 * @param use_seed_mode It is the boolean flag that indicates whether to use seed-based generation for the matrix. If set to true, the function will generate the matrix using a seed; if false, it will generate the matrix randomly.
 * @param seed_out It is a pointer to an unsigned char array where the generated seed will be stored if seed-based generation is used. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL.
 * 
 * @return void This function does not return any value. It modifies the provided matrix object directly and saves it to a file if necessary.
 */
void get_or_generate_matrix_with_seed(const char* prefix, int n, int k, int d, nmod_mat_t matrix,
                                     void (*generate_func)(slong, slong, slong, nmod_mat_t, FILE*),
                                     void (*generate_from_seed_func)(slong, slong, slong, nmod_mat_t, const unsigned char*, FILE*),
                                     FILE* output_file, bool regenerate, bool use_seed_mode, 
                                     unsigned char *seed_out) {
    if (use_seed_mode) {
        char* seed_filename = generate_seed_filename(prefix, n, k, d);
        if (seed_filename == NULL) {
            fprintf(stderr, "Failed to generate seed filename\n");
            return;
        }

        unsigned char seed[SEED_SIZE];
        
        if (!regenerate && load_seed(seed_filename, seed)) {
            generate_from_seed_func(n, k, d, matrix, seed, output_file);
            if (seed_out) memcpy(seed_out, seed, SEED_SIZE);
        } else {
            generate_random_seed(seed);
            save_seed(seed_filename, seed);
            generate_from_seed_func(n, k, d, matrix, seed, output_file);
            if (seed_out) memcpy(seed_out, seed, SEED_SIZE);
        }
        free(seed_filename);
    } else {
        char* filename = generate_matrix_filename(prefix, n, k, d);
        if (filename == NULL) {
            fprintf(stderr, "Failed to generate filename\n");
            return;
        }

        if (!regenerate && load_matrix(filename, matrix)) {
            // matrix loaded
        } else {
            generate_func(n, k, d, matrix, output_file);
            save_matrix(filename, matrix);
        }
        free(filename);
    }
}

/**
 * @brief It is a function that generates keys for a signature scheme based on the provided parameters and options.
 * 
 * This function generates keys for a signature scheme by creating a parity check matrix (H_A) and two generator matrices (G1 and G2) based on the provided code parameters (C_A, C1, C2). It supports both random generation and seed-based generation of matrices. The generated matrices are saved to files, and if seed-based generation is used, the seeds are also saved.
 * 
 * @param C_A It is a pointer to a struct code object that contains the parameters for the first code, including its length (n), dimension (k), and minimum distance (d). This code is used to generate the parity check matrix H_A.
 * @param C1 It is a pointer to a struct code object that contains the parameters for the first generator code, including its length (n), dimension (k), and minimum distance (d). This code is used to generate the first generator matrix G1.
 * @param C2 It is a pointer to a struct code object that contains the parameters for the second generator code, including its length (n), dimension (k), and minimum distance (d). This code is used to generate the second generator matrix G2.
 * @param H_A It is a pointer to an nmod_mat_t type, which represents the parity check matrix H_A to be generated. The function initializes this matrix with random entries or from a seed, depending on the options provided.
 * @param G1 It is a pointer to an nmod_mat_t type, which represents the first generator matrix G1 to be generated. The function initializes this matrix with random entries or from a seed, depending on the options provided.
 * @param G2 It is a pointer to an nmod_mat_t type, which represents the second generator matrix G2 to be generated. The function initializes this matrix with random entries or from a seed, depending on the options provided.
 * @param use_seed_mode It is a boolean flag that indicates whether to use seed-based generation for the matrices. If set to true, the function will generate the matrices using a seed; if false, it will generate the matrices randomly.
 * @param regenerate It is a boolean flag that indicates whether to regenerate the matrices even if they already exist. If set to true, the function will always generate new matrices; if false, it will load the existing matrices if available.
 * @param output_file It is a pointer to a FILE object where any output or debug information can be written. This parameter is optional and can be used for logging purposes, but in this implementation, it is not used.
 * @param h_a_seed It is a pointer to an unsigned char array where the generated seed for the parity check matrix H_A will be stored if seed-based generation is used. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL.
 * @param g1_seed It is a pointer to an unsigned char array where the generated seed for the first generator matrix G1 will be stored if seed-based generation is used. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL.
 * @param g2_seed It is a pointer to an unsigned char array where the generated seed for the second generator matrix G2 will be stored if seed-based generation is used. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file. If seed-based generation is not used, this parameter can be NULL.
 * 
 * @return void This function does not return any value. It directly modifies the provided matrices (H_A, G1, G2) and saves them to files if necessary. If seed-based generation is used, it also saves the generated seeds to files.
 */
void generate_keys(struct code* C_A, struct code* C1, struct code* C2,
                   nmod_mat_t H_A, nmod_mat_t G1, nmod_mat_t G2,
                   bool use_seed_mode, bool regenerate, FILE* output_file,
                   unsigned char* h_a_seed, unsigned char* g1_seed, unsigned char* g2_seed)
{
    get_or_generate_matrix_with_seed("H", C_A->n, C_A->k, C_A->d, H_A, 
                                     generate_parity_check_matrix, generate_parity_check_matrix_from_seed,
                                     output_file, regenerate, use_seed_mode, h_a_seed);

    get_or_generate_matrix_with_seed("G", C1->n, C1->k, C1->d, G1, 
                                     create_generator_matrix, create_generator_matrix_from_seed,
                                     output_file, regenerate, use_seed_mode, g1_seed);

    get_or_generate_matrix_with_seed("G", C2->n, C2->k, C2->d, G2, 
                                     create_generator_matrix, create_generator_matrix_from_seed,
                                     output_file, regenerate, use_seed_mode, g2_seed);

    if (use_seed_mode && PRINT) {
        fprintf(output_file, "\nUsing seed-based key generation\n");
        fprintf(output_file, "H_A seed: ");
        for (int i = 0; i < SEED_SIZE; i++) fprintf(output_file, "%02x", h_a_seed[i]);
        fprintf(output_file, "\nG1 seed: ");
        for (int i = 0; i < SEED_SIZE; i++) fprintf(output_file, "%02x", g1_seed[i]);
        fprintf(output_file, "\nG2 seed: ");
        for (int i = 0; i < SEED_SIZE; i++) fprintf(output_file, "%02x", g2_seed[i]);
        fprintf(output_file, "\n");
    }

    if (PRINT) {
        fprintf(output_file, "\nParity check matrix, H_A:\n\n");
        print_matrix(output_file, H_A);
        fprintf(output_file, "\nGenerator matrix, G1:\n\n");
        print_matrix(output_file, G1);
        fprintf(output_file, "\nGenerator matrix, G2:\n\n");
        print_matrix(output_file, G2);
    }
}
