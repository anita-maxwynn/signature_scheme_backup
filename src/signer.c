/**
 * @file signer.c
 * @brief This file contains the implementation of the signature generation function.
 * @details This function generates a signature based on the provided parameters, including the binary hash of the message, the code parameters, and the generator matrices.
 * It uses the Sodium library for cryptographic operations and matrix operations for handling the codewords.
 * The signature is generated by combining the binary hash with the generator matrix and ensuring that the weight of the signature meets the minimum distance requirement of the code.
 * The function also prints debug information if the PRINT flag is set.
 */
#include <sodium.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>
#include "signer.h"
#include "utils.h"
#include "matrix.h"
#include "constants.h"
/**
 * @brief This function generates a signature based on the provided parameters.
 * @details 
 * This function generates a digital signature for a given message using a code-based cryptographic approach.
 * The signature is created by constructing a hybrid generator matrix from two codes (C1 and C2), salting the message,
 * hashing it using SHA-256, and encoding the resulting binary hash vector as a codeword. The process ensures that
 * the signature meets the minimum weight requirement specified by code C_A. It uses matrix operations over finite fields
 * via the FLINT library (`nmod_mat_t`) and cryptographic hashing and randomness via Libsodium.
 *
 * The function performs the following steps:
 * 
 * 1. Allocate an array J to hold a random selection of indices from [0, C_A.n - 1].
 * 2. Generate a random permutation of size C1.n and store it in J.
 * 3. Initialize the matrix G_star (size C1.k × C_A.n) which will hold the combined generator matrix.
 * 4. For each column index i from 0 to C_A.n - 1:
 *     a. If i is in J (i.e., selected for G1), copy the corresponding column from G1 to G_star.
 *     b. Otherwise, copy the next available column from G2 to G_star.
 * 5. Free the random index array J as it's no longer needed.
 * 6. If PRINT is enabled, print the contents of G_star to the output file.
 * 7. Transpose G_star to obtain G_star_T.
 * 8. Compute F = H_A × G_star_T. This may be used for constraint checking or debugging.
 * 9. Begin a loop to compute a valid signature:
 *     a. Allocate and fill a buffer with the original message followed by a random salt of the same length.
 *     b. Hash the salted message using SHA-256.
 *     c. Convert the resulting hash into a binary vector (0s and 1s) to fill the bin_hash matrix.
 *     d. Multiply bin_hash with G_star to produce the signature matrix.
 *     e. If the weight (Hamming weight) of the signature is less than C_A.d (minimum distance), repeat the loop.
 * 10. If PRINT is enabled, print the binary hash matrix to the output file.
 * 11. Clear memory used by G_star and G_star_T.
 * @note This function assumes that the input matrices and codes are properly initialized and that the MOD constant is defined for finite field operations.
 * 
 * @param bin_hash It is a matrix that will hold the binary hash of the message.
 * @param message It is the input message for which the signature is being generated.
 * @param message_len It is the length of the input message in bytes.
 * @param C_A It is the derived code that defines the parameters for the signature generation, including the length of the code (n), the length of the message (k), and the minimum distance (d).
 * @param C1 It is the first code used in the signature generation process, which provides part of the generator matrix.
 * @param C2 It is the second code used in the signature generation process, which provides the remaining part of the generator matrix.
 * @param H_A It is the parity-check matrix for the derived code C_A, which is used to ensure that the generated signature meets the required properties.
 * @param G1 It is the generator matrix for the first code C1, which is used to construct part of the hybrid generator matrix.
 * @param G2 It is the generator matrix for the second code C2, which is used to construct the remaining part of the hybrid generator matrix.
 * @param F It is a matrix that will hold the product of the parity-check matrix H_A and the transposed hybrid generator matrix G_star_T. This is used for debugging or verification purposes.
 * @param signature It is the output matrix that will hold the generated signature for the input message.
 * @param output_file It is a file pointer to the output file where debug information will be printed if the PRINT flag is set.
 * @note The function uses the Sodium library for cryptographic operations and the FLINT library for matrix operations.
 */
void generate_signature(nmod_mat_t bin_hash, const unsigned char* message, size_t message_len,
                  struct code C_A, struct code C1, struct code C2,
                  nmod_mat_t H_A, nmod_mat_t G1, nmod_mat_t G2,
                  nmod_mat_t F, nmod_mat_t signature, FILE* output_file)
{
    unsigned long *J = malloc(C1.n * sizeof(unsigned long));
    generate_random_set(C_A.n, C1.n, J);

    if (PRINT) {
        fprintf(output_file, "\nRandom permutation: ");
        for (int i = 0; i < C1.n; ++i) {
            fprintf(output_file, "%lu ", J[i]);
        }
        fprintf(output_file, "\n");
    }

    nmod_mat_t G_star;
    nmod_mat_init(G_star, C1.k, C_A.n, MOD);

    int G1_index = 0, G2_index = 0;
    for (size_t i = 0; i < C_A.n; ++i) {

        if (J[G1_index] == i) {
            for (size_t col_index = 0; col_index < C1.k; ++col_index) {
                int val = nmod_mat_get_entry(G1, col_index, G1_index);
                nmod_mat_set_entry(G_star, col_index, i, val);
            }
            if (G1_index < C1.n - 1) {
                ++G1_index;
            }
        }
        else {
            for (size_t col_index = 0; col_index < C2.k; ++col_index) {
                int val = nmod_mat_get_entry(G2, col_index, G2_index);
                nmod_mat_set_entry(G_star, col_index, i, val);
            }
            if (G2_index < C2.n - 1) {
                ++G2_index;
            }
        }
    }
    free(J); 

    if (PRINT) {
        fprintf(output_file, "\nCombined matrix, G*:\n\n");
        print_matrix(output_file, G_star);
    }

    nmod_mat_t G_star_T;
    nmod_mat_init(G_star_T, C_A.n, C1.k, MOD);
    nmod_mat_transpose(G_star_T, G_star);

    nmod_mat_mul(F, H_A, G_star_T);

    do {
        const unsigned int salt_len = message_len;
        unsigned char salted_message[message_len + salt_len];
        for (int i = 0; i < message_len; ++i)
            salted_message[i] = message[i];
        for (int i = message_len; i < message_len + salt_len; ++i)
            salted_message[i] = randombytes_uniform(MOD); 

        unsigned char hash[crypto_hash_sha256_BYTES];
        crypto_hash_sha256(hash, salted_message, message_len + salt_len);
        size_t hash_size = sizeof(hash);
        
        for (size_t i = 0; i < message_len; ++i) {
            int val = hash[i % hash_size] % 2;
            nmod_mat_set_entry(bin_hash, 0, i, val);
        }

        nmod_mat_mul(signature, bin_hash, G_star);
    } while (weight(signature) < C_A.d);

    if (PRINT) {
        fprintf(output_file, "\nHash:\n\n");
        print_matrix(output_file, bin_hash);
    }
    
    nmod_mat_clear(G_star);
    nmod_mat_clear(G_star_T);
}