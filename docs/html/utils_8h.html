<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Signature Scheme Implementation: signature-scheme/include/utils.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Signature Scheme Implementation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('utils_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">utils.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Header file for utility functions used in the signature scheme.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;sodium.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;flint/flint.h&gt;</code><br />
<code>#include &lt;flint/nmod_mat.h&gt;</code><br />
<code>#include &quot;<a class="el" href="matrix_8h_source.html">matrix.h</a>&quot;</code><br />
</div>
<p><a href="utils_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0abfd8660e4c30a446271184dc904c96" id="r_a0abfd8660e4c30a446271184dc904c96"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0abfd8660e4c30a446271184dc904c96">weight</a> (nmod_mat_t array)</td></tr>
<tr class="memdesc:a0abfd8660e4c30a446271184dc904c96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the Hamming weight of a matrix row.  <br /></td></tr>
<tr class="memitem:a0a93e918b73ae9b05ef7036480bde696" id="r_a0a93e918b73ae9b05ef7036480bde696"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a93e918b73ae9b05ef7036480bde696">binary_entropy</a> (double p)</td></tr>
<tr class="memdesc:a0a93e918b73ae9b05ef7036480bde696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the binary entropy of a probability.  <br /></td></tr>
<tr class="memitem:abe5cbdd0620603e270684a5f978dc6c2" id="r_abe5cbdd0620603e270684a5f978dc6c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe5cbdd0620603e270684a5f978dc6c2">generate_random_set</a> (unsigned long upper_bound, unsigned long size, unsigned long set[size])</td></tr>
<tr class="memdesc:abe5cbdd0620603e270684a5f978dc6c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a random set of unique integers within a specified range.  <br /></td></tr>
<tr class="memitem:a1477b3bbfb233073dd258440041ad129" id="r_a1477b3bbfb233073dd258440041ad129"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1477b3bbfb233073dd258440041ad129">generate_matrix_filename</a> (const char *prefix, int n, int k, int d)</td></tr>
<tr class="memdesc:a1477b3bbfb233073dd258440041ad129"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a filename for a matrix based on prefix and dimensions.  <br /></td></tr>
<tr class="memitem:ab6d5b54e91321609a751e995f91e457b" id="r_ab6d5b54e91321609a751e995f91e457b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6d5b54e91321609a751e995f91e457b">save_matrix</a> (const char *filename, const nmod_mat_t matrix)</td></tr>
<tr class="memdesc:ab6d5b54e91321609a751e995f91e457b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a matrix to a text file in FLINT format.  <br /></td></tr>
<tr class="memitem:aefef1fc8ea5469aff22fce16404f82d4" id="r_aefef1fc8ea5469aff22fce16404f82d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aefef1fc8ea5469aff22fce16404f82d4">load_matrix</a> (const char *filename, nmod_mat_t matrix)</td></tr>
<tr class="memdesc:aefef1fc8ea5469aff22fce16404f82d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a matrix from a text file in FLINT format.  <br /></td></tr>
<tr class="memitem:a465f5441ca7fc78824e4e834b46a747f" id="r_a465f5441ca7fc78824e4e834b46a747f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a465f5441ca7fc78824e4e834b46a747f">file_exists</a> (const char *filename)</td></tr>
<tr class="memdesc:a465f5441ca7fc78824e4e834b46a747f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a file exists.  <br /></td></tr>
<tr class="memitem:aee6a52e0a51200073ab9001de380536c" id="r_aee6a52e0a51200073ab9001de380536c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee6a52e0a51200073ab9001de380536c">generate_seed_filename</a> (const char *prefix, int n, int k, int d)</td></tr>
<tr class="memdesc:aee6a52e0a51200073ab9001de380536c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a filename for a seed based on prefix and parameters.  <br /></td></tr>
<tr class="memitem:a277abfab9e3f799e1d38a673474eea75" id="r_a277abfab9e3f799e1d38a673474eea75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a277abfab9e3f799e1d38a673474eea75">save_seed</a> (const char *filename, const unsigned char *seed)</td></tr>
<tr class="memdesc:a277abfab9e3f799e1d38a673474eea75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saves a seed to a binary file.  <br /></td></tr>
<tr class="memitem:a2c0016f5618e2882d9261251b7fada82" id="r_a2c0016f5618e2882d9261251b7fada82"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c0016f5618e2882d9261251b7fada82">load_seed</a> (const char *filename, unsigned char *seed)</td></tr>
<tr class="memdesc:a2c0016f5618e2882d9261251b7fada82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a seed from a binary file.  <br /></td></tr>
<tr class="memitem:ab5e8b6289c8d0f065872cbe531443692" id="r_ab5e8b6289c8d0f065872cbe531443692"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5e8b6289c8d0f065872cbe531443692">read_file</a> (const char *filename)</td></tr>
<tr class="memdesc:ab5e8b6289c8d0f065872cbe531443692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the contents of a file into a string.  <br /></td></tr>
<tr class="memitem:ae7369b1b9abc62b85ee1e13cf4db0566" id="r_ae7369b1b9abc62b85ee1e13cf4db0566"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7369b1b9abc62b85ee1e13cf4db0566">read_file_or_generate</a> (const char *filename, int msg_len)</td></tr>
<tr class="memdesc:ae7369b1b9abc62b85ee1e13cf4db0566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a message from file or generates random message.  <br /></td></tr>
<tr class="memitem:a9b8caa6ee7537617613701fce02b972c" id="r_a9b8caa6ee7537617613701fce02b972c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8caa6ee7537617613701fce02b972c">load_params</a> (struct <a class="el" href="structcode.html">code</a> *C_A, struct <a class="el" href="structcode.html">code</a> *C1, struct <a class="el" href="structcode.html">code</a> *C2)</td></tr>
<tr class="memdesc:a9b8caa6ee7537617613701fce02b972c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads parameters for codes from a file.  <br /></td></tr>
<tr class="memitem:a086645594d782274944ebe259a8f748d" id="r_a086645594d782274944ebe259a8f748d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a086645594d782274944ebe259a8f748d">ensure_matrix_cache</a> ()</td></tr>
<tr class="memdesc:a086645594d782274944ebe259a8f748d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures matrix cache directory exists.  <br /></td></tr>
<tr class="memitem:aca16e242c76b24e74eddb68763efdead" id="r_aca16e242c76b24e74eddb68763efdead"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca16e242c76b24e74eddb68763efdead">ensure_output_directory</a> ()</td></tr>
<tr class="memdesc:aca16e242c76b24e74eddb68763efdead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensures output directory exists.  <br /></td></tr>
<tr class="memitem:adc1e64667d966146e31b71ac4476d009" id="r_adc1e64667d966146e31b71ac4476d009"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc1e64667d966146e31b71ac4476d009">normalize_message_length</a> (const char *msg, size_t msg_len, size_t target_len, size_t *final_len_out)</td></tr>
<tr class="memdesc:adc1e64667d966146e31b71ac4476d009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Normalizes message length by padding or truncating.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Header file for utility functions used in the signature scheme. </p>
</div><a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a0a93e918b73ae9b05ef7036480bde696" name="a0a93e918b73ae9b05ef7036480bde696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a93e918b73ae9b05ef7036480bde696">&#9670;&#160;</a></span>binary_entropy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double binary_entropy </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>p</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the binary entropy of a probability. </p>
<p>Calculates the binary entropy of a probability.</p>
<p>The binary entropy function computes the entropy of a binary random variable with probability p of being 1. It uses the formula: H(p) = -p * log2(p) - (1 - p) * log2(1 - p). The function checks if p is within the valid range (0, 1) and returns 0 if p is 0 or 1, as there is no uncertainty in those cases. The logarithm is computed using the log2 function from the math library, which calculates the base-2 logarithm.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A double representing the probability of a binary event occurring, where 0 &lt; p &lt; 1.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The binary entropy of the given probability p, which is a measure of uncertainty in bits.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the input probability p is a valid value between 0 and 1 (exclusive). If p is outside this range, the function will return 0, indicating no uncertainty. It does not handle cases where p is NaN or infinite. </dd></dl>

</div>
</div>
<a id="a086645594d782274944ebe259a8f748d" name="a086645594d782274944ebe259a8f748d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086645594d782274944ebe259a8f748d">&#9670;&#160;</a></span>ensure_matrix_cache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ensure_matrix_cache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures matrix cache directory exists. </p>
<p>Ensures matrix cache directory exists.</p>
<p>This function checks if the directory "matrix_cache" exists. If it does not, it creates the directory with permissions set to 0700 (read, write, and execute permissions for the owner only). This is useful for storing cached matrices used in the signature scheme. It uses the stat function to check for the directory's existence and mkdir to create it if necessary. The function does not return any value; it simply ensures that the directory is present before any matrix operations are performed.</p>
<dl class="section return"><dt>Returns</dt><dd>It does not return any value; it simply ensures that the matrix cache directory is present before any matrix operations are performed. </dd></dl>

</div>
</div>
<a id="aca16e242c76b24e74eddb68763efdead" name="aca16e242c76b24e74eddb68763efdead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca16e242c76b24e74eddb68763efdead">&#9670;&#160;</a></span>ensure_output_directory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ensure_output_directory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensures output directory exists. </p>
<p>Ensures output directory exists.</p>
<p>This function checks if the directory "output" exists. If it does not, it creates the directory with permissions set to 0700 (read, write, and execute permissions for the owner only). This is useful for storing output files generated by the signature scheme. It uses the stat function to check for the directory's existence and mkdir to create it if necessary. The function does not return any value; it simply ensures that the output directory is present before any output operations are performed.</p>
<dl class="section return"><dt>Returns</dt><dd>It does not return any value; it simply ensures that the output directory is present before any output operations are performed. </dd></dl>

</div>
</div>
<a id="a465f5441ca7fc78824e4e834b46a747f" name="a465f5441ca7fc78824e4e834b46a747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465f5441ca7fc78824e4e834b46a747f">&#9670;&#160;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int file_exists </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a file exists. </p>
<p>Checks if a file exists.</p>
<p>It takes a filename as input and tries to open the file using fopen with the "r" mode, which is for reading. If the file cannot be opened (for example, if it does not exist), fopen returns NULL. In this case, the function returns 0 to indicate that the file does not exist. If the file is successfully opened, it is immediately closed using fclose, and the function returns 1 to indicate that the file exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A pointer to a constant character string that specifies the name of the file to check for existence. The function will attempt to open this file in read mode.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 1 if the file exists (i.e., it can be opened in read mode), or 0 if the file does not exist (i.e., it cannot be opened).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function does not perform any additional checks on the file, such as verifying its contents or permissions. It simply checks for the existence of the file by trying to open it. If the file is successfully opened, it is closed immediately after checking. </dd></dl>

</div>
</div>
<a id="a1477b3bbfb233073dd258440041ad129" name="a1477b3bbfb233073dd258440041ad129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1477b3bbfb233073dd258440041ad129">&#9670;&#160;</a></span>generate_matrix_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * generate_matrix_filename </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a filename for a matrix based on prefix and dimensions. </p>
<p>Generates a filename for a matrix based on prefix and dimensions.</p>
<p>The function constructs a filename for a matrix by concatenating a predefined cache directory with a prefix and the dimensions of the matrix (n, k, d). The resulting filename is formatted as "cache_dir/prefix_n_k_d.txt", where cache_dir is defined as "matrix_cache/", and prefix, n, k, and d are provided as parameters. The function allocates memory for the filename string, formats it using sprintf, and returns the pointer to the generated filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>A pointer to a constant character string that serves as a prefix for the filename. This prefix is typically used to identify the type of matrix or its specific characteristics. Example prefixes could be "H_A", "G1", or "G2", depending on the context of the matrix being generated or stored. </td></tr>
    <tr><td class="paramname">n</td><td>The length of the code. </td></tr>
    <tr><td class="paramname">k</td><td>The dimension of the code. </td></tr>
    <tr><td class="paramname">d</td><td>The minimum distance of the code.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* A pointer to a dynamically allocated string containing the generated filename. If memory allocation fails, it returns NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function allocates memory for the filename string, so it is the caller's responsibility to free this memory when it is no longer needed. The maximum length of the generated filename is defined by MAX_FILENAME_LENGTH, which should be set appropriately to accommodate the longest expected filename. </dd></dl>

</div>
</div>
<a id="abe5cbdd0620603e270684a5f978dc6c2" name="abe5cbdd0620603e270684a5f978dc6c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5cbdd0620603e270684a5f978dc6c2">&#9670;&#160;</a></span>generate_random_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generate_random_set </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>upper_bound</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>set</em></span>[size]&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a random set of unique integers within a specified range. </p>
<p>Generates a random set of unique integers within a specified range.</p>
<p>The function generates a random set of unique integers from 0 to upper_bound - 1, ensuring that the size of the set is equal to size. It uses the modern Fisher-Yates shuffle algorithm to randomly permute an array of integers from 0 to upper_bound - 1, and then selects the first size elements from this shuffled array. The resulting set is sorted in ascending order using the qsort function with a custom comparison function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">upper_bound</td><td>An unsigned long integer representing the upper limit of the range from which unique integers will be selected. The function will generate integers in the range [0, upper_bound). </td></tr>
    <tr><td class="paramname">size</td><td>An unsigned long integer representing the number of unique integers to be generated in the set. The function will ensure that the size of the generated set is equal to this value. </td></tr>
    <tr><td class="paramname">set</td><td>A pointer to an array of unsigned long integers where the generated unique integers will be stored. The size of this array should be at least size elements to hold the generated set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Algorithm:<ol type="1">
<li>Initialize an array arr containing all integers from 0 to upper_bound - 1.</li>
<li>Shuffle the array in-place using the modern Fisher-Yates shuffle: ◦ Iterate from the last element to the second element. ◦ In each iteration, generate a random index j such that 0 &lt;= j &lt;= i. ◦ Swap the elements at indices i and j.</li>
<li>Copy the first size elements from the shuffled array into set.</li>
<li>Sort the set array in ascending order. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="aee6a52e0a51200073ab9001de380536c" name="aee6a52e0a51200073ab9001de380536c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6a52e0a51200073ab9001de380536c">&#9670;&#160;</a></span>generate_seed_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * generate_seed_filename </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>prefix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a filename for a seed based on prefix and parameters. </p>
<p>Generates a filename for a seed based on prefix and parameters.</p>
<p>The function constructs a filename for a seed by concatenating a predefined cache directory with a prefix and the parameters n, k, and d. The resulting filename is formatted as "cache_dir/prefix_n_k_d_seed.bin", where cache_dir is defined as "matrix_cache/", and prefix, n, k, and d are provided as parameters. The function allocates memory for the filename string, formats it using snprintf, and returns the pointer to the generated filename.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>A pointer to a constant character string that serves as a prefix for the filename. This prefix is typically used to identify the type of seed or its specific characteristics, such as "H_A", "G1", or "G2", depending on the context of the seed being generated or stored. </td></tr>
    <tr><td class="paramname">n</td><td>An integer representing the length of the code. This value is used to uniquely identify the seed associated with a specific code length. </td></tr>
    <tr><td class="paramname">k</td><td>An integer representing the dimension of the code. This value is used to uniquely identify the seed associated with a specific code dimension. </td></tr>
    <tr><td class="paramname">d</td><td>An integer representing the minimum distance of the code. This value is used to uniquely identify the seed associated with a specific code minimum distance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* A pointer to a dynamically allocated string containing the generated filename. If memory allocation fails, it returns NULL. The caller is responsible for freeing this memory when it is no longer needed. </dd></dl>

</div>
</div>
<a id="aefef1fc8ea5469aff22fce16404f82d4" name="aefef1fc8ea5469aff22fce16404f82d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefef1fc8ea5469aff22fce16404f82d4">&#9670;&#160;</a></span>load_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int load_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a matrix from a text file in FLINT format. </p>
<p>Loads a matrix from a text file in FLINT format.</p>
<p>It opens a file with the specified filename for reading. If it fails to open the file, it returns 0. It then reads the dimensions of the matrix (number of rows and columns) from the file. If it fails to read these dimensions, it closes the file and returns 0. The function clears any existing data in the provided matrix, initializes it with the specified dimensions, and then reads each entry of the matrix from the file, setting the corresponding entry in the matrix using nmod_mat_set_entry. If it fails to read any value, it closes the file and returns 0. Finally, it closes the file and returns 1 to indicate success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A pointer to a constant character string that specifies the name of the file from which the matrix will be loaded. </td></tr>
    <tr><td class="paramname">matrix</td><td>A pointer to an nmod_mat_t type, which represents a matrix in the FLINT library.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int 1 if the matrix was successfully loaded from the file, or 0 if there was an error (e.g., file not found, failed to read dimensions or values).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The file should be in a specific text format that includes the dimensions of the matrix followed by its entries. </dd></dl>

</div>
</div>
<a id="a9b8caa6ee7537617613701fce02b972c" name="a9b8caa6ee7537617613701fce02b972c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8caa6ee7537617613701fce02b972c">&#9670;&#160;</a></span>load_params()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_params </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structcode.html">code</a> *</td>          <td class="paramname"><span class="paramname"><em>C_A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcode.html">code</a> *</td>          <td class="paramname"><span class="paramname"><em>C1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structcode.html">code</a> *</td>          <td class="paramname"><span class="paramname"><em>C2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads parameters for codes from a file. </p>
<p>Loads parameters for codes from a file.</p>
<p>It opens a file named "params.txt" in read mode and reads key-value pairs from it. The keys correspond to parameters of the codes, such as "H_A_n", "H_A_k", "H_A_d", "G1_n", "G1_k", "G1_d", "G2_n", "G2_k", and "G2_d". For each key, it assigns the corresponding value to the appropriate field in the provided code structures (C_A, C1, and C2). If the file cannot be opened, it prints an error message and returns false. If all parameters are successfully loaded, it returns true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C_A</td><td>A pointer to the concatenated code structure, which contains parameters for the concatenated code (C_A). </td></tr>
    <tr><td class="paramname">C1</td><td>A pointer to the first generator code structure, which contains parameters for the first code (C1). </td></tr>
    <tr><td class="paramname">C2</td><td>A pointer to the second generator code structure, which contains parameters for the second code (C2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the parameters were successfully loaded from the file, meaning that the file was opened, all key-value pairs were read, and the corresponding fields in the code structures were set. </dd>
<dd>
false If there was an error opening the file or if any key-value pair could not be read, indicating that the parameters were not loaded successfully.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the file "params.txt" exists and is formatted correctly with key-value pairs. If any key is missing or if the file cannot be read, the function will not set the corresponding fields in the code structures. </dd></dl>

</div>
</div>
<a id="a2c0016f5618e2882d9261251b7fada82" name="a2c0016f5618e2882d9261251b7fada82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0016f5618e2882d9261251b7fada82">&#9670;&#160;</a></span>load_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool load_seed </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a seed from a binary file. </p>
<p>The function takes a filename and a pointer to an unsigned char array (seed) as input. It opens the specified file in binary read mode ("rb"). If the file cannot be opened, it returns false. It then reads SEED_SIZE bytes from the file into the seed array using fread. After reading, it closes the file and checks if the number of bytes read matches SEED_SIZE. If they match, it returns true, indicating that the seed was successfully loaded; otherwise, it returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A pointer to a constant character string that specifies the name of the file from which the seed will be loaded. The file should contain binary data representing the seed. </td></tr>
    <tr><td class="paramname">seed</td><td>A pointer to an unsigned char array where the loaded seed data will be stored. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the seed was successfully loaded from the file, meaning that the file was opened, the seed data was read, and the correct number of bytes was read. </dd>
<dd>
false If there was an error opening the file or if the number of bytes read does not match SEED_SIZE, indicating that the seed was not loaded successfully. </dd></dl>

</div>
</div>
<a id="adc1e64667d966146e31b71ac4476d009" name="adc1e64667d966146e31b71ac4476d009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc1e64667d966146e31b71ac4476d009">&#9670;&#160;</a></span>normalize_message_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * normalize_message_length </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>msg_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>target_len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *</td>          <td class="paramname"><span class="paramname"><em>final_len_out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Normalizes message length by padding or truncating. </p>
<p>Normalizes message length by padding or truncating.</p>
<p>The function takes a message, its length, a target length, and an optional pointer to store the final length. It allocates memory for a new message of the target length. If the original message is shorter than the target length, it copies the original message and fills the remaining space with random uppercase letters (A-Z). If the original message is longer than the target length, it truncates it to fit. If the lengths match, it simply copies the original message. The function returns the newly created message and updates the final length if requested.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msg</td><td>A pointer to a constant character string that represents the original message to be normalized. The message can be of any length, and the function will either pad it with random characters or truncate it to fit the target length. </td></tr>
    <tr><td class="paramname">msg_len</td><td>The length of the original message in bytes. This value is used to determine whether the message needs to be padded or truncated to match the target length. </td></tr>
    <tr><td class="paramname">target_len</td><td>The desired length of the normalized message. The function will ensure that the final message has this exact length by either padding it with random characters or truncating it if necessary. </td></tr>
    <tr><td class="paramname">final_len_out</td><td>A pointer to a size_t variable where the final length of the normalized message will be stored. This parameter is optional; if it is NULL, the function will not update the final length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* A pointer to a dynamically allocated string containing the normalized message.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function allocates memory for the new message, so it is the caller's responsibility to free this memory when it is no longer needed. If memory allocation fails, the function will print an error message and return NULL. </dd></dl>

</div>
</div>
<a id="ab5e8b6289c8d0f065872cbe531443692" name="ab5e8b6289c8d0f065872cbe531443692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e8b6289c8d0f065872cbe531443692">&#9670;&#160;</a></span>read_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * read_file </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the contents of a file into a string. </p>
<p>Reads the contents of a file into a string.</p>
<p>It opens the specified file in read mode, checks if the file was opened successfully, and then reads its contents into a buffer. The function first seeks to the end of the file to determine its length, rewinds to the beginning, allocates memory for the buffer, and reads the file's contents into it. Finally, it closes the file and returns the buffer containing the file's contents as a null-terminated string. If any step fails (e.g., file not found, memory allocation failure), it prints an error message and returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A pointer to a constant character string that specifies the name of the file to be read. The function will attempt to open this file in read mode and read its contents. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* A pointer to a dynamically allocated string containing the contents of the file. If the file cannot be opened or is empty, it returns NULL.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for freeing the returned buffer after use to avoid memory leaks. </dd></dl>

</div>
</div>
<a id="ae7369b1b9abc62b85ee1e13cf4db0566" name="ae7369b1b9abc62b85ee1e13cf4db0566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7369b1b9abc62b85ee1e13cf4db0566">&#9670;&#160;</a></span>read_file_or_generate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * read_file_or_generate </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>msg_len</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a message from file or generates random message. </p>
<p>Reads a message from file or generates random message.</p>
<p>It attempts to open the specified file in read mode. If the file is successfully opened, it checks its length. If the length is zero or less, it generates a random message of a specified length and saves it to the file. If the file contains valid data, it reads the contents into a dynamically allocated string and returns it. If the file cannot be opened, it generates a random message, saves it to the file, and returns that message.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A pointer to a constant character string that specifies the name of the file to read the message from. If the file does not exist or is empty, a random message will be generated and saved to this file. </td></tr>
    <tr><td class="paramname">msg_len</td><td>An integer representing the length of the message to be generated if the file is empty or does not exist. The function will generate a random message of this length using uppercase letters (A-Z). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>char* A pointer to a dynamically allocated string containing the message read from the file or the generated random message. If memory allocation fails or if there is an error reading the file, it returns NULL. The caller is responsible for freeing the returned string after use. </dd></dl>

</div>
</div>
<a id="ab6d5b54e91321609a751e995f91e457b" name="ab6d5b54e91321609a751e995f91e457b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6d5b54e91321609a751e995f91e457b">&#9670;&#160;</a></span>save_matrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void save_matrix </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>matrix</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a matrix to a text file in FLINT format. </p>
<p>Saves a matrix to a text file in FLINT format.</p>
<p>The function opens a file with the specified filename for writing. If it fails to open the file, it prints an error message and returns. It then retrieves the number of rows and columns of the matrix using nmod_mat_nrows and nmod_mat_ncols, respectively, and writes these dimensions to the file. After that, it iterates through each entry of the matrix, retrieves its value using nmod_mat_entry, and writes it to the file in a space-separated format. Finally, it closes the file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A pointer to a constant character string that specifies the name of the file where the matrix will be saved. The file will be created if it does not exist, or overwritten if it does. </td></tr>
    <tr><td class="paramname">matrix</td><td>A pointer to an nmod_mat_t type, which represents a matrix in the FLINT library. The matrix should be initialized and populated with values before calling this function. The function will save the matrix in a specific text format that includes its dimensions followed by its entries.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function does not perform any error checking on the matrix itself, such as ensuring it is initialized or has valid dimensions. It assumes that the matrix is properly set up before calling this function. The file will be created in the current working directory, and if the file already exists, it will be overwritten. </dd></dl>

</div>
</div>
<a id="a277abfab9e3f799e1d38a673474eea75" name="a277abfab9e3f799e1d38a673474eea75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a277abfab9e3f799e1d38a673474eea75">&#9670;&#160;</a></span>save_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool save_seed </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>seed</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Saves a seed to a binary file. </p>
<p>The function takes a filename and a pointer to an unsigned char array (seed) as input. It opens the specified file in binary write mode ("wb"). If the file cannot be opened, it returns false. It then writes the seed data to the file using fwrite, which writes SEED_SIZE bytes from the seed array to the file. After writing, it closes the file and checks if the number of bytes written matches SEED_SIZE. If they match, it returns true, indicating that the seed was successfully saved; otherwise, it returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>A pointer to a constant character string that specifies the name of the file where the seed will be saved. The file will be created if it does not exist, or overwritten if it does. </td></tr>
    <tr><td class="paramname">seed</td><td>A pointer to an unsigned char array that contains the seed data to be saved. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true If the seed was successfully saved to the file, meaning that the file was opened, the seed data was written, and the correct number of bytes was written. </dd>
<dd>
false If there was an error opening the file or if the number of bytes written does not match SEED_SIZE, indicating that the seed was not saved successfully. </dd></dl>

</div>
</div>
<a id="a0abfd8660e4c30a446271184dc904c96" name="a0abfd8660e4c30a446271184dc904c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abfd8660e4c30a446271184dc904c96">&#9670;&#160;</a></span>weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long weight </td>
          <td>(</td>
          <td class="paramtype">nmod_mat_t</td>          <td class="paramname"><span class="paramname"><em>array</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the Hamming weight of a matrix row. </p>
<p>Calculates the Hamming weight of a matrix row.</p>
<p>The Hamming weight is the number of non-zero elements in a row of a matrix. This function iterates through the first row of the provided matrix and counts how many entries are equal to 1, which corresponds to the Hamming weight. It assumes that the matrix is represented as an nmod_mat_t type from the FLINT library, which allows for efficient access to matrix entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>A pointer to an nmod_mat_t type, which represents a matrix in the FLINT library.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long The Hamming weight of the first row of the matrix, which is the count of entries equal to 1.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function assumes that the matrix has at least one row and that the entries are in the range of 0 to MOD-1, where MOD is defined in the FLINT library. It does not handle cases where the matrix is empty or has no rows. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_2f80228ae10e8992c0359fcc0b448edb.html">signature-scheme</a></li><li class="navelem"><a href="dir_db9c7b5bda17bb91c755428bded24c4d.html">include</a></li><li class="navelem"><a href="utils_8h.html">utils.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
