/**
 * @file utils.c
 * @brief implementation of utility functions for file and directory management, matrix operations, and random number generation used in the signature scheme.
 * 
 * implementation of utility functions for file and directory management, matrix operations, and random number generation used in the signature scheme. This file 
 * provides functions to ensure the existence of necessary directories, create and manage matrix files, randomly generate sets, perform various matrix operations 
 * and message manipulations. It begins with standard and project-specific headers, and includes functions like ensure_matrix_cache and 
 * ensure_output_directory to create necessary directories if missing. It defines compare_ints for sorting, weight for computing the Hamming weight of a matrix row, 
 * and binary_entropy for entropy calculation. Random subsets are generated using generate_random_set, which applies the Fisher-Yates shuffle 
 * and sorting. Matrix-related tasks such as naming, saving, and loading are handled using FLINT matrix functions through generate_matrix_filename, 
 * save_matrix, and load_matrix. File handling includes checking for existence, saving seeds, and managing input/output files. 
 * read_file_or_generate ensures a message is available by reading it from a file or generating one if missing, while normalize_message_length ensures proper length. 
 * Finally, load_params loads code parameters from a file into program structures. The module emphasizes robustness and reusability, streamlining I/O, 
 * randomness, and matrix handling for the broader cryptographic system.
 */

#include <stdbool.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include "params.h"
#include "utils.h"
#include "constants.h"

/**
 * @brief checks the existence of the matrix cache directory and creates it if it does not exist.
 * 
 * This function checks if the directory "matrix_cache" exists. If it does not, it creates the directory with permissions set to 0700 (read, write, and execute permissions for the owner only). This is useful for storing cached matrices used in the signature scheme. It uses the stat function to check for the directory's existence and mkdir to create it if necessary. The function does not return any value; it simply ensures that the directory is present before any matrix operations are performed.
 * 
 * @return It does not return any value; it simply ensures that the matrix cache directory is present before any matrix operations are performed.
 */
void ensure_matrix_cache() {
    struct stat st = {0};
    if (stat("matrix_cache", &st) == -1) {
        mkdir("matrix_cache", 0700);
    }
}

/**
 * @brief checks the existence of the output directory and creates it if it does not
 * exist.
 * 
 * This function checks if the directory "output" exists. If it does not, it
 * creates the directory with permissions set to 0700 (read, write, and execute
 * permissions for the owner only). This is useful for storing output files generated by the
 * signature scheme. It uses the stat function to check for the directory's existence and mkdir to create it if necessary. The function does not return any value; it simply
 * ensures that the output directory is present before any output operations are
 * performed.
 * 
 * @return It does not return any value; it simply ensures that the output directory is
 * present before any output operations are performed.
 */
void ensure_output_directory() {
    struct stat st = {0};
    if (stat(OUTPUT_DIR, &st) == -1) {
        mkdir(OUTPUT_DIR, 0700);
    }
}

/**
 * @brief This function compares two integers for sorting purposes.
 * 
 * This function is used as a comparison function for sorting arrays of integers. It takes two pointers to integers, dereferences them to get the actual integer values, and then compares them. It returns -1 if the first integer is less than the second, 1 if the first integer is greater than the second, and 0 if they are equal. This function is typically used with the qsort function from the C standard library to sort arrays of integers in ascending order.
 * 
 * @param a Pointer to the first element (of type const void*) to compare.
 * @param b Pointer to the second element (of type const void*) to compare.
 * 
 * @return int Comparison result: -1, 0, or 1.
 */
static int compare_ints(const void* a, const void* b) {
    int arg1 = *(const int*) a;
    int arg2 = *(const int*) b;
 
    if (arg1 < arg2) return -1;
    if (arg1 > arg2) return 1;
    return 0;
}

/**
 * @brief This function calculates the Hamming weight of a given matrix row.
 * 
 * The Hamming weight is the number of non-zero elements in a row of a matrix. This
 * function iterates through the first row of the provided matrix and counts how
 * many entries are equal to 1, which corresponds to the Hamming weight. It assumes
 * that the matrix is represented as an nmod_mat_t type from the FLINT library, which allows for efficient access to matrix
 * entries.
 * 
 * @param array It is a pointer to an nmod_mat_t type, which represents a matrix in the FLINT library.
 * 
 * @return long The function returns the Hamming weight of the first row of the matrix,
 * which is the count of entries equal to 1.
 * 
 * @note The function assumes that the matrix has at least one row and that the entries
 * are in the range of 0 to MOD-1, where MOD is defined in the FLINT library. It
 * does not handle cases where the matrix is empty or has no rows.
 */
// Hamming weight
long weight(nmod_mat_t array) {
    long weight = 0;
    for (size_t i = 0; i < array->c; ++i) {
        if (nmod_mat_get_entry(array, 0, i) == 1) {
            ++weight;
        }
    }
    return weight;
}

/**
 * @brief This function calculates the binary entropy of a given probability.
 * 
 * The binary entropy function computes the entropy of a binary random variable
 * with probability p of being 1. It uses the formula: H(p) = -p * log2(p) - (1 - p) * log2(1 - p).
 * The function checks if p is within the valid range (0, 1) and returns 0 if p is 0 or 1, as there is no uncertainty in those cases. The logarithm is computed
 * using the log2 function from the math library, which calculates the base-2 logarithm.
 * 
 * @param p It is a double representing the probability of a binary event occurring, where 0
 * < p < 1.
 * 
 * @return double It returns the binary entropy of the given probability p, which is a measure of uncertainty in bits.
 * 
 * @note The function assumes that the input probability p is a valid value between 0 and 1 (exclusive). If p is outside this range, the function will return 0, indicating no uncertainty.
 * It does not handle cases where p is NaN or infinite.
 */
double binary_entropy(double p) {
    if (p <= 0 || p >= 1) {
        // If p is 0 or 1, the entropy is 0, because there's no uncertainty
        return 0;
    }

    return -p * log2(p) - (1 - p) * log2(1 - p);
}

/**
 * @brief This function generates a random set of unique integers within a specified range
 * and sort the original set according to the ascending order.
 * 
 * The function generates a random set of unique integers from 0 to upper_bound - 1, ensuring that the size of the set is equal to size. It uses the modern Fisher-Yates shuffle algorithm to randomly permute an array
 * of integers from 0 to upper_bound - 1, and then selects the first size elements from this shuffled array. The resulting set is sorted in ascending
 * order using the qsort function with a custom comparison function.
 * 
 * @param upper_bound It is an unsigned long integer representing the upper limit of the range from
 * which unique integers will be selected. The function will generate integers in the
 * range [0, upper_bound).
 * @param size It is an unsigned long integer representing the number of unique integers to be
 * generated in the set. The function will ensure that the size of the generated
 * set is equal to this value.
 * @param set It is a pointer to an array of unsigned long integers where the generated unique
 * integers will be stored. The size of this array should be at least size elements to hold the generated set.
 * 
 * @note * 1. Initialize an array arr containing all integers from 0 to upper_bound - 1.
 * 1. Shuffle the array in-place using the modern Fisher-Yates shuffle:
 *   ◦ Iterate from the last element to the second element.
 *   ◦ In each iteration, generate a random index j such that 0 <= j <= i.
 *   ◦ Swap the elements at indices i and j.
 * 2. Copy the first size elements from the shuffled array into set.
 * 3. Sort the set array in ascending order.
 */
// Fisher Yates shuffle
void generate_random_set(unsigned long upper_bound, unsigned long size, unsigned long set[size]) {
    unsigned long *arr = malloc(upper_bound * sizeof(unsigned long));
    for (size_t i = 0; i < upper_bound; i++) {
        arr[i] = i;
    }

    for (size_t i = upper_bound - 1; i > 0; i--) {
        unsigned long j = randombytes_uniform(i + 1);
        unsigned long temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    for (size_t i = 0; i < size; ++i) {
        set[i] = arr[i];
    }

    free(arr);
    qsort(set, size, sizeof(set[0]), compare_ints);
}

/**
 * @brief This function generates a filename for a matrix based on a prefix and its
 * dimensions.
 * 
 * The function constructs a filename for a matrix by concatenating a predefined
 * cache directory with a prefix and the dimensions of the matrix (n, k, d). The
 * resulting filename is formatted as "cache_dir/prefix_n_k_d.txt", where cache_dir is defined as "matrix_cache/", and prefix, n, k, and d are provided as parameters. The function allocates memory for the filename
 * string, formats it using sprintf, and returns the pointer to the generated filename.
 * 
 * @param prefix It is a pointer to a constant character string that serves as a prefix for the
 * filename. This prefix is typically used to identify the type of matrix or its
 * specific characteristics. example prefixes could be "H_A", "G1", or "G2", depending
 * on the context of the matrix being generated or stored.
 * @param n It is the length of the code.
 * @param k It is the dimension of the code.
 * @param d it is the minimum distance of the code.
 * 
 * @return char* It returns a pointer to a dynamically allocated string containing the
 * generated filename. If memory allocation fails, it returns NULL.
 * 
 * @note The function allocates memory for the filename string, so it is the caller's
 * responsibility to free this memory when it is no longer needed. The maximum length
 * of the generated filename is defined by MAX_FILENAME_LENGTH, which should be set appropriately to accommodate the longest expected
 * filename.
 */
// Function to generate a filename for a matrix
char* generate_matrix_filename(const char* prefix, int n, int k, int d) {
    char* filename = malloc(MAX_FILENAME_LENGTH);
    if (filename == NULL) {
        fprintf(stderr, "Memory allocation failed\n");
        return NULL;
    }
    sprintf(filename, "%s%s_%d_%d_%d.txt", CACHE_DIR, prefix, n, k, d);
    return filename;
}

/**
 * @brief This function saves a matrix to a text file in a specific format(FLINT matrix
 * format).
 * 
 * Thhe function opens a file with the specified filename for writing. If it fails
 * to open the file, it prints an error message and returns. It then retrieves the
 * number of rows and columns of the matrix using nmod_mat_nrows and nmod_mat_ncols, respectively, and writes these dimensions to the file. After that, it iterates
 * through each entry of the matrix, retrieves its value using nmod_mat_entry, and writes it to the file in a space-separated format. Finally, it closes the
 * file.
 * 
 * @param filename It is a pointer to a constant character string that specifies the name of the
 * file where the matrix will be saved. The file will be created if it does not
 * exist, or overwritten if it does.
 * @param matrix It is a pointer to an nmod_mat_t type, which represents a matrix in the FLINT library. The matrix should be
 * initialized and populated with values before calling this function. The function
 * will save the matrix in a specific text format that includes its dimensions
 * followed by its entries.
 * 
 * @note The function does not perform any error checking on the matrix itself, such as
 * ensuring it is initialized or has valid dimensions. It assumes that the matrix is
 * properly set up before calling this function. The file will be created in the
 * current working directory, and if the file already exists, it will be
 * overwritten.
 */
// Function to save a matrix to a text file
void save_matrix(const char* filename, const nmod_mat_t matrix) {
    FILE* file = fopen(filename, "w");
    if (file == NULL) {
        fprintf(stderr, "Error opening file for writing: %s\n", filename);
        return;
    }
    
    slong rows = nmod_mat_nrows(matrix);
    slong cols = nmod_mat_ncols(matrix);
    fprintf(file, "%ld %ld\n", rows, cols);
    
    for (slong i = 0; i < rows; i++) {
        for (slong j = 0; j < cols; j++) {
            slong value = nmod_mat_entry(matrix, i, j);
            fprintf(file, "%lu ", value);
        }
        fprintf(file, "\n");
    }
    
    fclose(file);
}

/**
 * @brief This function loads a matrix from a text file in a specific format (FLINT matrix
 * format).
 * 
 * It opens a file with the specified filename for reading. If it fails to open the
 * file, it returns 0. It then reads the dimensions of the matrix (number of rows
 * and columns) from the file. If it fails to read these dimensions, it closes the
 * file and returns 0. The function clears any existing data in the provided
 * matrix, initializes it with the specified dimensions, and then reads each entry of the
 * matrix from the file, setting the corresponding entry in the matrix using nmod_mat_set_entry. If it fails to read any value, it closes the file and returns 0. Finally, it
 * closes the file and returns 1 to indicate success.
 * 
 * @param filename It is a pointer to a constant character string that specifies the name of the
 * file from which the matrix will be loaded.
 * @param matrix It is a pointer to an nmod_mat_t type, which represents a matrix in the FLINT library.
 * 
 * @return int It returns 1 if the matrix was successfully loaded from the file, or 0 if
 * there was an error (e.g., file not found, failed to read dimensions or values).
 * 
 * @note The file should be in a specific text format that includes the dimensions of the
 * matrix followed by its entries.
 */
// Function to load a matrix from a text file
int load_matrix(const char* filename, nmod_mat_t matrix) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        return 0;  // File doesn't exist or can't be opened
    }
    
    slong rows, cols;
    if (fscanf(file, "%ld %ld", &rows, &cols) != 2) {
        fclose(file);
        return 0;  // Failed to read dimensions
    }
    
    nmod_mat_clear(matrix);
    nmod_mat_init(matrix, rows, cols, MOD);
    
    for (slong i = 0; i < rows; i++) {
        for (slong j = 0; j < cols; j++) {
            unsigned long value;
            if (fscanf(file, "%lu", &value) != 1) {
                fclose(file);
                return 0;  // Failed to read value
            }
            nmod_mat_set_entry(matrix, i, j, value);
        }
    }
    
    fclose(file);
    return 1;
}

/**
 * @brief This function checks if a file exists by attempting to open it in read mode.
 * 
 * It takes a filename as input and tries to open the file using fopen with the "r" mode, which is for reading. If the file cannot be opened (for
 * example, if it does not exist), fopen returns NULL. In this case, the function returns 0 to indicate that the file
 * does not exist. If the file is successfully opened, it is immediately closed using
 * fclose, and the function returns 1 to indicate that the file exists.
 * 
 * @param filename It is a pointer to a constant character string that specifies the name of the
 * file to check for existence. The function will attempt to open this file in read
 * mode.
 * 
 * @return int It returns 1 if the file exists (i.e., it can be opened in read mode), or 0
 * if the file does not exist (i.e., it cannot be opened).
 * 
 * @note The function does not perform any additional checks on the file, such as
 * verifying its contents or permissions. It simply checks for the existence of the file
 * by trying to open it. If the file is successfully opened, it is closed
 * immediately after checking.
 */
int file_exists(const char* filename) {
    FILE* file = fopen(filename, "r");
    if (file == NULL) {
        return 0;
    }
    fclose(file);
    return 1;
}

/**
 * @brief This function generates a filename for a seed based on a prefix and its
 * parameters.
 * 
 * The function constructs a filename for a seed by concatenating a predefined
 * cache directory with a prefix and the parameters n, k, and d. The resulting filename
 * is formatted as "cache_dir/prefix_n_k_d_seed.bin", where cache_dir is defined as "matrix_cache/", and prefix, n, k, and d are provided as parameters. The function allocates memory for the filename
 * string, formats it using snprintf, and returns the pointer to the generated filename.
 * 
 * @param prefix It is a pointer to a constant character string that serves as a prefix for the
 * filename. This prefix is typically used to identify the type of seed or its
 * specific characteristics, such as "H_A", "G1", or "G2", depending on the context of
 * the seed being generated or stored.
 * @param n It is an integer representing the length of the code. This value is used to
 * uniquely identify the seed associated with a specific code length.
 * @param k It is an integer representing the dimension of the code. This value is used to
 * uniquely identify the seed associated with a specific code dimension.
 * @param d It is an integer representing the minimum distance of the code. This value is
 * used to uniquely identify the seed associated with a specific code minimum
 * distance.
 * 
 * @return char* It returns a pointer to a dynamically allocated string containing the
 * generated filename. If memory allocation fails, it returns NULL. The caller is
 * responsible for freeing this memory when it is no longer needed.
 */
char* generate_seed_filename(const char* prefix, int n, int k, int d) {
    char* filename = malloc(MAX_FILENAME_LENGTH);
    if (filename) {
        snprintf(filename, MAX_FILENAME_LENGTH, "%s/%s_%d_%d_%d_seed.bin", CACHE_DIR, prefix, n, k, d);
    }
    return filename;
}

/**
 * @brief It is a function that saves a seed to a binary file.
 * 
 * The function takes a filename and a pointer to an unsigned char array (seed) as input. It opens the specified file in binary write mode ("wb"). If the file cannot be opened, it returns false. It then writes the seed data to the file using fwrite, which writes SEED_SIZE bytes from the seed array to the file. After writing, it closes the file and checks if the number of bytes written matches SEED_SIZE. If they match, it returns true, indicating that the seed was successfully saved; otherwise, it returns false.
 * 
 * @param filename It is the pointer to a constant character string that specifies the name of the file where the seed will be saved. The file will be created if it does not exist, or overwritten if it does.
 * @param seed It is a pointer to an unsigned char array that contains the seed data to be saved. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file.
 * @return true It returns true if the seed was successfully saved to the file, meaning that the file was opened, the seed data was written, and the correct number of bytes was written.
 * @return false It returns false if there was an error opening the file or if the number of bytes written does not match SEED_SIZE, indicating that the seed was not saved successfully.
 */
bool save_seed(const char* filename, const unsigned char *seed) {
    FILE *file = fopen(filename, "wb");
    if (!file) return false;
    
    size_t written = fwrite(seed, 1, SEED_SIZE, file);
    fclose(file);
    return written == SEED_SIZE;
}

/**
 * @brief It is a function that loads a seed from a binary file.
 * 
 * The function takes a filename and a pointer to an unsigned char array (seed) as input. It opens the specified file in binary read mode ("rb"). If the file cannot be opened, it returns false. It then reads SEED_SIZE bytes from the file into the seed array using fread. After reading, it closes the file and checks if the number of bytes read matches SEED_SIZE. If they match, it returns true, indicating that the seed was successfully loaded; otherwise, it returns false.
 * 
 * @param filename It is a pointer to a constant character string that specifies the name of the file from which the seed will be loaded. The file should contain binary data representing the seed.
 * @param seed It is a pointer to an unsigned char array where the loaded seed data will be stored. The size of this array should be equal to SEED_SIZE, which is defined in the constants header file.
 * @return true It returns true if the seed was successfully loaded from the file, meaning that the file was opened, the seed data was read, and the correct number of bytes was read.
 * @return false It is false if there was an error opening the file or if the number of bytes read does not match SEED_SIZE, indicating that the seed was not loaded successfully.
 */
bool load_seed(const char* filename, unsigned char *seed) {
    FILE *file = fopen(filename, "rb");
    if (!file) return false;
    
    size_t read = fread(seed, 1, SEED_SIZE, file);
    fclose(file);
    return read == SEED_SIZE;
}

/**
 * @brief This function reads the contents of a file into a dynamically allocated string.
 * 
 * It opens the specified file in read mode, checks if the file was opened successfully, and then reads its contents into a buffer. The function first seeks to the end of the file to determine its length, rewinds to the beginning, allocates memory for the buffer, and reads the file's contents into it. Finally, it closes the file and returns the buffer containing the file's contents as a null-terminated string. If any step fails (e.g., file not found, memory allocation failure), it prints an error message and returns NULL.
 * 
 * @param filename It is a pointer to a constant character string that specifies the name of the file to be read. The function will attempt to open this file in read mode and read its contents.
 * @return char* It returns a pointer to a dynamically allocated string containing the contents of the file. If the file cannot be opened or is empty, it returns NULL.
 * 
 * @note The caller is responsible for freeing the returned buffer after use to avoid memory leaks.
 */
char *read_file(const char *filename) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        fprintf(stderr, "Error: could not open file: %s\n", filename);
        return NULL;
    }

    fseek(fp, 0, SEEK_END);
    long length = ftell(fp);
    rewind(fp);

    if (length <= 0) {
        fprintf(stderr, "Error: file is empty or unreadable: %s\n", filename);
        fclose(fp);
        return NULL;
    }

    char *buffer = malloc(length + 1);
    if (!buffer) {
        fprintf(stderr, "Memory allocation failed\n");
        fclose(fp);
        return NULL;
    }

    size_t read = fread(buffer, 1, length, fp);
    fclose(fp);

    buffer[read] = '\0';
    return buffer;
}


/**
 * @brief This function reads a message from a file or generates a random message if the file is empty or does not exist.
 * 
 * It attempts to open the specified file in read mode. If the file is successfully opened, it checks its length. If the length is zero or less, it generates a random message of a specified length and saves it to the file. If the file contains valid data, it reads the contents into a dynamically allocated string and returns it. If the file cannot be opened, it generates a random message, saves it to the file, and returns that message.
 * 
 * @param filename It is a pointer to a constant character string that specifies the name of the file to read the message from. If the file does not exist or is empty, a random message will be generated and saved to this file.
 * @param msg_len It is an integer representing the length of the message to be generated if the file is empty or does not exist. The function will generate a random message of this length using uppercase letters (A-Z).
 * @return char* It returns a pointer to a dynamically allocated string containing the message read from the file or the generated random message. If memory allocation fails or if there is an error reading the file, it returns NULL. The caller is responsible for freeing the returned string after use.
 */
char *read_file_or_generate(const char *filename, int msg_len) {
    FILE *fp = fopen(filename, "r");
    if (fp) {
        fseek(fp, 0, SEEK_END);
        long length = ftell(fp);
        rewind(fp);

        if (length <= 0) {
            fprintf(stderr, "Warning: file is empty, generating message instead.\n");
            fclose(fp);
        } else {
            char *buffer = malloc(length + 1);
            if (!buffer) {
                fprintf(stderr, "Memory allocation failed\n");
                fclose(fp);
                return NULL;
            }

            size_t read = fread(buffer, 1, length, fp);
            buffer[read] = '\0';
            fclose(fp);
            return buffer;
        }
    }

    // Fallback: generate message
    char *msg = malloc(msg_len + 1);
    if (!msg) {
        fprintf(stderr, "Memory allocation failed for fallback message\n");
        return NULL;
    }

    for (int i = 0; i < msg_len; ++i) {
        msg[i] = random_range(65, 90);  // A-Z
    }
    msg[msg_len] = '\0';

    FILE *fout = fopen(filename, "w");
    if (fout) {
        fwrite(msg, 1, msg_len, fout);
        fclose(fout);
        printf("No valid message file found. Generated random message saved to '%s'\n", filename);
    } else {
        fprintf(stderr, "Warning: could not write fallback message to file.\n");
    }

    return msg;
}

/**
 * @brief This function loads parameters for the codes from a file.
 * 
 * It opens a file named "params.txt" in read mode and reads key-value pairs from it. The keys correspond to parameters of the codes, such as "H_A_n", "H_A_k", "H_A_d", "G1_n", "G1_k", "G1_d", "G2_n", "G2_k", and "G2_d". For each key, it assigns the corresponding value to the appropriate field in the provided code structures (C_A, C1, and C2). If the file cannot be opened, it prints an error message and returns false. If all parameters are successfully loaded, it returns true.
 * 
 * @param C_A It is a pointer to the concatenated code structure, which contains parameters for the concatenated code (C_A).
 * @param C1 It is a pointer to the first generator code structure, which contains parameters for the first code (C1).
 * @param C2 It is a pointer to the second generator code structure, which contains parameters for the second code (C2).
 * @return true It returns true if the parameters were successfully loaded from the file, meaning that the file was opened, all key-value pairs were read, and the corresponding fields in the code structures were set.
 * @return false It returns false if there was an error opening the file or if any key-value pair could not be read, indicating that the parameters were not loaded successfully.
 * 
 * @note The function assumes that the file "params.txt" exists and is formatted correctly with key-value pairs. If any key is missing or if the file cannot be read, the function will not set the corresponding fields in the code structures.
 */
bool load_params(struct code *C_A, struct code *C1, struct code *C2) {
    FILE *file = fopen(PARAM_PATH, "r");
    if (!file) {
        fprintf(stderr, "Error: Could not open params.txt\n");
        return false;
    }

    char key[16];
    unsigned long val;
    while (fscanf(file, "%15s %lu", key, &val) == 2) {
        if      (strcmp(key, "H_A_n") == 0) C_A->n = val;
        else if (strcmp(key, "H_A_k") == 0) C_A->k = val;
        else if (strcmp(key, "H_A_d") == 0) C_A->d = val;
        else if (strcmp(key, "G1_n") == 0)  C1->n = val;
        else if (strcmp(key, "G1_k") == 0)  C1->k = val;
        else if (strcmp(key, "G1_d") == 0)  C1->d = val;
        else if (strcmp(key, "G2_n") == 0)  C2->n = val;
        else if (strcmp(key, "G2_k") == 0)  C2->k = val;
        else if (strcmp(key, "G2_d") == 0)  C2->d = val;
    }

    fclose(file);
    return true;
}

/**
 * @brief This function normalizes the length of a message to a target length by padding or truncating it.
 * 
 * The function takes a message, its length, a target length, and an optional pointer to store the final length. It allocates memory for a new message of the target length. If the original message is shorter than the target length, it copies the original message and fills the remaining space with random uppercase letters (A-Z). If the original message is longer than the target length, it truncates it to fit. If the lengths match, it simply copies the original message. The function returns the newly created message and updates the final length if requested.
 * 
 * @param msg It is a pointer to a constant character string that represents the original message to be normalized. The message can be of any length, and the function will either pad it with random characters or truncate it to fit the target length.
 * @param msg_len It is the length of the original message in bytes. This value is used to determine whether the message needs to be padded or truncated to match the target length.
 * @param target_len It is the desired length of the normalized message. The function will ensure that the final message has this exact length by either padding it with random characters or truncating it if necessary.
 * @param final_len_out It is a pointer to a size_t variable where the final length of the normalized message will be stored. This parameter is optional; if it is NULL, the function will not update the final length.
 * @return char* It returns a pointer to a dynamically allocated string containing the normalized message.
 * 
 * @note The function allocates memory for the new message, so it is the caller's responsibility to free this memory when it is no longer needed. If memory allocation fails, the function will print an error message and return NULL.
 */
char *normalize_message_length(const char *msg, size_t msg_len, size_t target_len, size_t *final_len_out) {
    char *fixed_msg = malloc(target_len + 1);
    if (!fixed_msg) {
        fprintf(stderr, "Memory allocation failed\n");
        return NULL;
    }

    if (msg_len < target_len) {
        memcpy(fixed_msg, msg, msg_len);
        for (size_t i = msg_len; i < target_len; ++i) {
            fixed_msg[i] = 'A' + (rand() % 26);
        }
        printf("Warning: message too short — padded to %lu chars\n", target_len);
    } else if (msg_len > target_len) {
        memcpy(fixed_msg, msg, target_len);
        printf("Warning: message too long — truncated to %lu chars\n", target_len);
    } else {
        memcpy(fixed_msg, msg, target_len);
    }

    fixed_msg[target_len] = '\0';
    if (final_len_out) *final_len_out = target_len;
    return fixed_msg;
}